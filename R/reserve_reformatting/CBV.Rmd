---
title: "CBV"
author: "Kim Cressman"
date: "2022-05-25; latest update `r Sys.Date()`"
output: 
    html_document:
        toc: true
        toc_depth: 2
        code_folding: hide
---

Use this template to set up the wrangling for an individual reserve's files.  


```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE,
                      warning = FALSE,
                      message = FALSE)
```

```{r}
library(tidyverse)
library(readxl)
library(writexl)
library(leaflet)
library(rgdal)
library(stringi)  # for stri_sub_replace()

reserve <- "CBV"
```

# Setup  

## Helpful functions  

Because I'll be doing this repetitively on similar data files....  

```{r}
source(here::here("R", "sourced", "00_helper_functions.R"))
```

## Data path  

Just one file to read here.  

1/9/23: path updated to corrected file from Scott L., which was actually sent in June 2022.  

```{r}
# path_start <- here::here("submitted_data", "data", reserve, 
#                          "CBNERRVA Veg Data GI Reserve for Chris Peter.xlsx")

path_start <- here::here("submitted_data", "data", reserve, 
                         "GI Vegetation Data All Years for Kim.xlsx")

problem_path_out <- here::here("wrangled_data", "combined_with_issues")

path_out <- here::here("wrangled_data", "CDMO")

# create the output folder if it doesn't already exist
if(!dir.exists(path_out)){
    dir.create(path_out)
}
```


Read into a list and combine  **MODIFY FOR DIFFERENT DATA TYPES**  

# CDMO formatted input  

This section will compile code to read in and combine files that are already in CDMO format. Then a long CDMO-format file will be generated, after reconciling column names, dates, and putting things in order. The NaMaSTe template file will be generated from the CDMO-format file.  

```{r}
shts <- excel_sheets(path_start)
dat_in <- list()

for(i in seq_along(shts)){
    tmp <- read_cdmo(path_start, 
                           worksheet = shts[i]) %>% 
        mutate(across(c("Density Quad Size", "Distance"),
                      as.character))
    
    dat_in[[i]] <- tmp
}

if(janitor::compare_df_cols_same(dat_in)){
    dat_all <- bind_rows(dat_in)
} else {
    warning("dfs WILL NOT BIND")
}
```

Had to force Density Quad Size (contains "NC" - looks like Density and Canopy Height(s) also contain this, and it looks to mean "not collected") and Distance ("60 ish") to character. Canopy Height 1 column still contains some "~" characters (~120; ~70-80; ~80-90).    

# Checks  

## Column names and types?  

Look for different column names for the same thing.  

```{r}
names(dat_all)
```

Deal with the dual density columns  

```{r}
names(dat_all)[18] <- "Quad_count"
names(dat_all)[19] <- "Density"
```



## Duplicates in date-site-transect-plot-species  

Include subplot if used by reserve. Want an empty tibble below.    

```{r}
unique(dat_all$Subplot)

# # subplot included
# dat_all %>% 
#    group_by(Date, SiteID, TransectID, PlotID, Subplot, Species) %>% 
#     tally() %>% 
#     filter(n > 1) %>% 
#     select(Date:Species, n)

# no subplot included
dat_all %>%
   group_by(Date, SiteID, TransectID, PlotID,  Species) %>%
    tally() %>%
    filter(n > 1) %>%
    select(Date:Species, n)

# just one dupe: 

# dat_all %>%
#     filter(SiteID == "GI",
#            TransectID == "T1",
#            PlotID == "P12",
#            Species == "IVAFRU") %>% 
#     View()
```


2013-09-17 GI T1 P12 IVAFRU duplicated. Counter rows 33 and 36. One for cover is "1-5" with canopy height as 23.0; other is "26-50" for cover and 230.0 for canopy height.  

Per Scott L. email on 1/11/23: "please remove Counter Row 106 (with IVAFRU at 26-50 percent cover).   I think that was entered erroneously."

```{r}
dat_all2 <- dat_all %>% 
    filter(Counter != 106)

ivafru_dupes <- dat_all %>%
    mutate(rownum = row_number()) %>%
    filter(lubridate::ymd(Date) == "2013-09-17",
           SiteID == "GI",
           TransectID == "T1",
           PlotID == "P12",
           Species == "IVAFRU") %>%
    select(rownum, `% Cover`)

# want to get rid of the second one
dat_all <- dat_all %>%
    filter(row_number() != ivafru_dupes$rownum[2])

```

## Distance column as text  

Also there are some numbers that seem to be weirdly floating decimal points - round to tenths place.  

```{r}
dat_all <- dat_all %>% 
    mutate(Distance = case_when(Distance == "60 ish" ~ "60",
                                TRUE ~ Distance),
           Distance = as.numeric(Distance),
           Distance = round(Distance, 1))
```

## Elevation two columns  

Combine into one and round to 4 digits (again, weirdly floating decimals here).  

```{r}
dat_all <- dat_all %>% 
    mutate(`Elevation (NAVD88)` = case_when(`Elevation (NAVD88)` == "no data" ~ NA_character_,
                                            TRUE ~ `Elevation (NAVD88)`),
           `Elevation (NAVD88)` = as.numeric(`Elevation (NAVD88)`),
           Elevation_NAVD88 = case_when(is.na(Elevation) ~ `Elevation (NAVD88)`,
                                        !is.na(Elevation) ~ Elevation,
                                        TRUE ~ NA_real_)) %>% 
    select(-Elevation, -`Elevation (NAVD88)`)
```

## Change braun-blanquet category covers to midpoint  

per TWG at January 2023 meeting  

represented as % Cover in data frame, insert "Cover" column  

```{r}
dat_all <- dat_all %>% 
    mutate(Cover = case_match(`% Cover`,
                              "Trace" ~ 0.1,
                              "1-5" ~ 3,
                              "6-25" ~ 15,
                              "26-50" ~ 38,
                              "26-60" ~ 38, # assuming typo
                              "51-75" ~ 63,
                              "76-95" ~ 85,
                              "96-100" ~ 98))

# case_match new in dplyr 1.1.0! Hooray!
```



## Check station/plot names  

```{r}
unique(dat_all$Reserve)
```

```{r}
dat_all %>% 
    select(Reserve, SiteID, TransectID, PlotID) %>% 
    distinct() %>% 
    knitr::kable()
```


### 'Distance' discrepancies  

```{r}
stn_dupes <- dat_all %>% 
    select(Reserve, SiteID, TransectID, PlotID,
           Distance) %>% 
    distinct() %>% 
    janitor::get_dupes(-Distance)

stn_dupes
```

I think I won't let this bother me. Looks like they may have measured or estimated distance on each date rather than using one number consistently.

### Lat/Long discrepancies  



## Mangroves or SAV present?  

Mangrove species are: *Avicennia germinans*, *Laguncularia racemosa*, *Rhizophora mangle*. Check for these before discarding a `Height` or `Diameter` column.   

The following sums will be 0 if none of the genus names were found in the species column. This is only set to detect the first few letteres in case of misspellings, so if any sums are above 0, it deserves further investigation.  

```{r}
spp_all <- sort(unique(dat_all$Species))
knitr::kable(spp_all)
sum(str_detect(spp_all, "Avic"))
sum(str_detect(spp_all, "Lagunc"))
sum(str_detect(spp_all, "Rhizo"))

```

Also check for anything other than 'E' in 'Type'.

```{r}
unique(dat_all$Type)
```

## Check species names  

```{r}
dat_all$Species <- str_replace(dat_all$Species, pattern = "  ", replacement = " ")
    
spp <- dat_all %>% 
    group_by(Species) %>% 
    tally()

# spp_out_path <- here::here("wrangled_data", "combined_with_issues", paste0(reserve, "_species.csv")) 
# 
# write.csv(spp, spp_out_path, row.names = FALSE)
```


# Fix discrepancies  

Species  

```{r}
# read in updates  
spp_fixed <- read_xlsx(here::here("wrangled_data",
                                  "combined_with_issues",
                                  "CBV_species_updates.xlsx")) %>% 
    select(Species_to = Species,
           Species = Species_Original)

dat_all <- dat_all %>% 
    full_join(spp_fixed) %>% 
    select(-Species) %>% 
    rename(Species = Species_to) 
```


# HEIGHT STUFF  

First deal with the text entries  

```{r}
# to_replace <- tribble(
#     ~"entered", ~"change_to",
#     "~120", "120",
#     "~70-80", "75",
#     "~80-90", "85",
#     "n/a", NA_character_,
#     "-", NA_character_,
#     "NC", NA_character_
# )

dat_all <- dat_all %>% 
    mutate(`Canopy Height 1` = case_match(`Canopy Height 1`,
                                          "~120" ~ "120",
                                          "~70-80" ~ "75",
                                          "~80-90" ~ "85",
                                          "n/a" ~ NA_character_,
                                          "-" ~ NA_character_,
                                          "NC" ~ NA_character_,
                                          .default = `Canopy Height 1`),
           `Canopy Height 2` = case_match(`Canopy Height 2`,
                                          "~120" ~ "120",
                                          "~70-80" ~ "75",
                                          "~80-90" ~ "85",
                                          "n/a" ~ NA_character_,
                                          "-" ~ NA_character_,
                                          "NC" ~ NA_character_,
                                          .default = `Canopy Height 2`),
           `Canopy Height 3` = case_match(`Canopy Height 3`,
                                          "~120" ~ "120",
                                          "~70-80" ~ "75",
                                          "~80-90" ~ "85",
                                          "n/a" ~ NA_character_,
                                          "-" ~ NA_character_,
                                          "NC" ~ NA_character_,
                                          .default = `Canopy Height 3`))
```

## Function to deal with columns  


-  separate heights with a slash into flowering and not-flowering height columns  
-  if there wasn't a slash, the value was placed into the not-flowering height column  
-  if there was an 'f' at the end of the value, that value was put into the flowering height column, and an NA was placed in the not-flowering height column  
-  a 'to_average' column was generated, using not-flowering height if one was present, and flowering height otherwise  
-  all the new columns were turned into numeric format  

```{r}
fl_cols <- function(df, col){
    fl_name <- paste0("flowering_", col)
    nfl_name <- paste0("NOT_flowering_", col)
    avg_name <- paste0("toAverage_", col)
    df %>%
        separate({{col}}, into = c("f_ht", "NOTf_ht"), sep = "/",
                 extra = "drop", fill = "left",
                 remove = FALSE) %>% 
        mutate(f_ht = ifelse(str_ends(NOTf_ht, "f"), str_remove(NOTf_ht, "f"), f_ht),
               NOTf_ht = ifelse(str_ends(NOTf_ht, "f"), NA, NOTf_ht),
               to_average = ifelse(!is.na(NOTf_ht), NOTf_ht, f_ht),
               across(c(f_ht, NOTf_ht, to_average), as.numeric)) %>% 
        relocate(to_average, .after = NOTf_ht) %>% 
        rename(!!fl_name := f_ht,
               !!nfl_name := NOTf_ht,
               !!avg_name := to_average)
}
```

### Apply the function  

```{r}
cbv_hts <- dat_all %>% 
    fl_cols("Canopy Height 1") %>% 
    fl_cols("Canopy Height 2") %>% 
    fl_cols("Canopy Height 3")
```


## Column wrangling  

Pull out columns for Month, Day, and Year; and format Date as mm/dd/yyyy for the CDMO output file.  

```{r}
dat_all <- dat_all %>% 
    mutate(
        Year = lubridate::year(Date),
        Month = lubridate::month(Date),
        Day = lubridate::mday(Date),
        Date = format(Date, "%m/%d/%Y")
    ) 
```



## CDMO format (long)  

CDMO column names, in order. If columns had different names, or there were additional ones, account for that here.    

```{r}
dat_cdmo <- dat_all %>% 
    select(
        "Reserve",
        "Type",
        "Date",
        "SiteID",
        "TransectID",
        "PlotID",
        "Subplot",
        "Rep",
        "SSAM-1",
        "Lat",
        "Long",
        "Distance",
        "Orthometric Height",
        "Height Relative to MLLW",
        "Species",
        "Cover",
        "Density",
        "Maximum Canopy Height",
        "Average Canopy Height",
        "Diameter",
        "Height",
        "QAQC"
    )
```


## Write the CDMO data frame to a file. **Modify for each reserve**  

```{r}
write.csv(dat_cdmo, here::here(problem_path_out, reserve, "_issues.csv"), 
          row.names= FALSE,
          na = "")
```

```{r}
write_xlsx(dat_cdmo, path = here::here(path_out, reserve, "_CDMO.xlsx"),
           format_headers = TRUE)
```


# NaMaSTe tables  

Get rid of any NAs in lat/long; we want station characteristics.  

```{r}
station_table <- dat_cdmo %>% 
    select(Reserve,
           SiteID,
           TransectID,
           PlotID,
           Lat,
           Long,
           Type,
           "SSAM-1") %>% 
    filter(!is.na(Lat),
           !is.na(Long)) %>% 
    distinct()
```

Do any plots have multiple rows?  

```{r}
station_table %>% 
    group_by(Reserve, SiteID, TransectID, PlotID) %>% 
    tally() %>% 
    arrange(desc(n)) %>% 
    knitr::kable()
```

Are all stations actually represented? If the below output is FALSE, there's a problem to fix. If TRUE, proceed.     

```{r}
stns_all <- dat_cdmo %>% 
    select(Reserve, SiteID, TransectID, PlotID) %>% 
    distinct()

nrow(stns_all) == nrow(station_table)
```